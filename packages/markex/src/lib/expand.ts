import { parseCommentText } from './parse'
import { type Rule, type RuleSet } from './rules/types'
import { type Html, type Root } from 'mdast'
import { remark } from 'remark'
import remarkGfm from 'remark-gfm'
import type { JsonObject } from 'type-fest'
import { CONTINUE, EXIT, visit } from 'unist-util-visit'

// String
export type ExpandStringOptions = ExpandAstOptions
export async function expandString(
	markdown: string,
	options: ExpandStringOptions,
): Promise<{ expandedString: string; report: string[] }> {
	const ast = remark().use(remarkGfm).parse(markdown)
	const { expandedAst, report } = await expandAst(ast, options)

	return {
		expandedString: remark().use(remarkGfm).stringify(expandedAst),
		report,
	}
}

// AST
export type ExpandAstOptions = {
	expansionRules: RuleSet
	keywordPrefix?: string
	meta?: boolean
}
export async function expandAst(
	ast: Root,
	options: ExpandAstOptions,
): Promise<{ expandedAst: Root; report: string[] }> {
	const { expansionRules, keywordPrefix = '', meta = false } = options

	// Extract template expansion commands from comment nodes
	// https://github.com/syntax-tree/mdast/blob/main/readme.md

	// Happens in two passes to accommodate async rules

	// Save promises as we go
	const newContent: Array<{
		applySequence: number
		args: JsonObject | undefined
		getContent: Rule['getContent']
		openingComment: Html
	}> = []

	// TODO stay at top level
	// First pass adds closing comments if needed and removes existing children
	visit(ast, 'html', (node, index, parent) => {
		if (parent !== undefined && index !== undefined) {
			// Parse the comment contents
			const result = parseCommentText(node.value)
			if (result === undefined) return CONTINUE
			const { args, keyword } = result

			// Look for a matching rule in the rule set
			const matchingRule = Object.values(expansionRules).find(
				(rule) => `${keywordPrefix}${rule.keyword}` === keyword,
			)
			if (matchingRule === undefined) return CONTINUE

			// The keyword already contains the prefix from the parser
			// Look for a closing closing comment, if there is one we'll delete everything
			// between the opening and closing comments
			const closingTagIndex = getClosingTagIndex(ast, index, keyword)
			const tagsToReplace = closingTagIndex ? closingTagIndex - index - 1 : 0
			parent.children.splice(index + 1, tagsToReplace)

			// Add closing tag if it doesn't exist
			if (closingTagIndex === undefined) {
				const closingNode: Html = {
					type: 'html',
					value: `<!-- /${keyword} -->`,
				}
				parent.children.splice(index + 1, 0, closingNode)
			}

			// Save the reference to promise function and its args
			// to generate new nodes later on
			newContent.push({
				applySequence: matchingRule.applicationOrder ?? 0,
				args,
				getContent: matchingRule.getContent,
				openingComment: node,
			})
		}
	})

	// Sort newContent in place to apply expansion rules in the order they're received in the array
	newContent.sort((a, b) => a.applySequence - b.applySequence)

	// Execution, not just promise resolution, must be deferred to here
	// to ensure table of contents has all generated headings
	for (const { args, getContent, openingComment } of newContent) {
		const newMarkdownString = await getContent(ast, args)
		const newNodes = remark().use(remarkGfm).parse(newMarkdownString).children
		const openingCommentIndex = ast.children.indexOf(openingComment)
		ast.children.splice(openingCommentIndex + 1, 0, ...newNodes)
	}

	// Add or remove the meta comment if requested
	const message = 'Warning: Content in HTML comment blocks generated by markex'
	// Remove existing meta comments
	ast.children = ast.children.filter(
		(node) => !(node.type === 'html' && node.value.startsWith(`<!-- ${message}`)),
	)

	if (meta) {
		const date = new Date().toISOString().slice(0, 10)
		const metaComment: Html = {
			type: 'html',
			value: `<!-- ${message} on ${date}. -->`,
		}
		ast.children.unshift(metaComment)
	}

	return {
		expandedAst: ast,
		report: newContent.map(({ openingComment }) => openingComment.value),
	}
}

// Helpers
function getClosingTagIndex(
	ast: Root,
	startFromIndex: number,
	keywordWithPrefix: string,
): number | undefined {
	let matchingIndex: number | undefined
	visit(ast, 'html', (node, index, parent) => {
		if (parent !== undefined && index !== undefined && index >= startFromIndex) {
			const result = parseCommentText(node.value)
			if (result === undefined) return CONTINUE

			if (`/${keywordWithPrefix}` === result.keyword) {
				matchingIndex = index
				return EXIT
			}
		}
	})
	return matchingIndex
}
