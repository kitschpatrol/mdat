import log from '../lib/log'
import { getSoleRecord } from './utilities'
import { type Root } from 'mdast'
import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import plur from 'plur'
import { type JsonObject } from 'type-fest'
import type { Merge } from 'type-fest'
import { type SimplifyDeep } from 'type-fest/source/merge-deep'
import { z } from 'zod'

// Basic interface for comment expanders

/**
 * Strict normalized rules used internally.
 * Rules normalized to a form with async content functions and other default metadata
 * Simplifies processing elsewhere, while retaining flexibility for rule authors
 */
export type NormalizedRule = {
	/**
	 * The order in which the rule should be applied during processing
	 * Helpful if a rule depends on the presence of content generated by another rule
	 * If undefined, application order is 0
	 */
	applicationOrder?: number
	content: (options: JsonObject, ast: Root) => Promise<string>
	/**
	 * The expected order of the keyword in the document relative to other expander comments.
	 * Used for validation purposes.
	 * Leave undefined to order skip validation.
	 */
	order?: number
	/**
	 * Whether the presence of the keyword comment in the document is required.
	 * Used for validation purposes.
	 * Leave undefined to skip presence validation.
	 */
	required?: boolean
}

// More flexible rules used in the public interface
export type Rule =
	| Merge<
			NormalizedRule,
			{
				/**
				 * Gets content to expand into the comment.
				 * Can be a simple string for direct replacement, a function that returns a string, or an async function that returns a string.
				 *
				 * If a function is provided, it will be passed the following arguments:
				 *
				 * @param options
				 * JSON object of options parsed from the comment site, e.g.:
				 * `<!-- keyword({something: true}) -->` or
				 * `<!-- keyword {something: true}-->`
				 * Sets options to {something: true}
				 *
				 * @param ast
				 * Markdown abstract syntax tree containing the entire parsed document. Useful for expanders that need the entire document context, such as when generating a table of contents. Do not mutate the AST, instead return a new string.
				 *
				 * @returns A string with the generated content. The string will be parsed as markdown and inserted into the document at the comment's location.
				 */
				content: ((options: JsonObject, ast: Root) => Promise<string> | string) | string
			}
	  >
	/**
	 * The markdown string to expand at the comment site.
	 */
	| string

/**
 * Rules are record objects whose keys match strings inside a Markdown comment, and values explain what should be expanded at the comment site.
 *
 * The record value may be a string, or an object containing additional metadata, possibly with a function to invoke to generate content.
 *
 * @example Most basic rule:
 * { basic: 'content' }
 *
 * @example Rule with metadata:
 * { basic-meta: { required: true, content: 'content'} }
 *
 * @example Rule with dynamic content:
 * { basic-date: { content: () => `${new Date().toISOString()}` } }
 */
export type Rules = SimplifyDeep<Record<string, Rule>>

export type NormalizedRules = SimplifyDeep<Record<string, NormalizedRule>>

/**
 *
 * @param rules - An array that can mix string that are paths to rule .js module files or .json files
 * that will be dynamically loaded with Rules objects that have already been
 * loaded. Rules will be merged from left to right, so later rules will override
 * earlier rules. Also normalizes shorthand rules into a consistent shape.
 * @returns
 */
export async function loadRules(rules: Array<Rules | string>): Promise<NormalizedRules> {
	// Load modules as needed
	let finalRules: Rules = {}

	for (const ruleSetOrRuleModulePath of rules) {
		if (typeof ruleSetOrRuleModulePath === 'string') {
			// Load module or json
			const ruleModulePath = ruleSetOrRuleModulePath
			const fullPath = path.resolve(process.cwd(), ruleModulePath)
			const extension = path.extname(ruleModulePath).toLowerCase()

			if (extension === '.json') {
				// Load json...
				// Every path to a primitive becomes a rule...
				const jsonString = await fs.readFile(fullPath, 'utf8')
				const jsonObject = JSON.parse(jsonString) as JsonObject
				const jsonRules = flattenJson(jsonObject)

				validateRules(jsonRules)

				finalRules = { ...finalRules, ...jsonRules }
			} else if (extension === '.js') {
				// Load module
				const { default: ruleModule } = (await import(
					fileURLToPath(new URL(`file://${fullPath}`))
				)) as { default: Rules }

				// TODO support TS? See SystemJS and SystemJS babel plugin

				const rulesLoadedCount = Object.entries(ruleModule).length

				if (rulesLoadedCount === 0) {
					throw new Error(`No rules found in module: "${ruleModulePath}"`)
				} else {
					validateRules(ruleModule)

					log.info(`Loaded ${rulesLoadedCount} rules from file: "${ruleModulePath}"`)
				}

				finalRules = { ...finalRules, ...ruleModule }
			} else {
				throw new Error(`Unsupported rule file extension: "${extension}"`)
			}
		} else {
			// Merge rule into finalRules
			const ruleSet = ruleSetOrRuleModulePath

			const rulesLoadedCount = Object.entries(ruleSet).length

			if (rulesLoadedCount === 0) {
				throw new Error(`No rules found in internal module`)
			} else {
				validateRules(ruleSet)

				log.info(
					`Loaded ${rulesLoadedCount} ${plur('rule', rulesLoadedCount)} from internal module`,
				)
			}

			finalRules = { ...finalRules, ...ruleSet }
		}
	}

	const finalRulesLoadedCount = Object.entries(finalRules).length
	if (finalRulesLoadedCount === 0) {
		throw new Error(`No rules found. Did you forget to pass in paths to a rules module?`)
	}

	log.info(
		`Loaded ${finalRulesLoadedCount} magicmark comment expansion ${plur('rule', finalRulesLoadedCount)} in total`,
	)

	const normalizedRules = normalizeRules(finalRules)

	return normalizedRules
}

// Helpers
function normalizeRules(rules: Rules): NormalizedRules {
	const normalizedRules: NormalizedRules = {}

	for (const [keyword, rule] of Object.entries(rules)) {
		if (typeof rule === 'string') {
			// Rule is just a simple string replacement
			normalizedRules[keyword] = {
				// eslint-disable-next-line @typescript-eslint/require-await
				content: async () => rule,
			}
		} else if (typeof rule.content === 'string') {
			// Rule is a string replacement with metadata
			// Merge any existing metadata, but turn content into a function
			const ruleContent = rule.content // Needed for type narrowing
			normalizedRules[keyword] = {
				...rule,
				// eslint-disable-next-line @typescript-eslint/require-await
				content: async () => ruleContent,
			}
		} else {
			// Rule content returns a function, wrapped so it can be sync or async
			const ruleContent = rule.content // Needed for type narrowing
			normalizedRules[keyword] = {
				...rule,
				content: async (options: JsonObject, ast: Root) => ruleContent(options, ast),
			}
		}
	}

	return normalizedRules
}

function validateRules(rules: Rules) {
	// Validate, throws on errors
	try {
		normalizedRulesSchema.parse(rules)
	} catch (error) {
		if (error instanceof Error) {
			throw new TypeError(`Error validating rules: ${error.message}`)
		}
	}
}

// Some duplication here, but less painful than inferring the TS types
// from more extensive Zod schemas that would require more extensive duplication
// of the JsonObject and Root types.
const normalizedRulesSchema = z.record(
	z.union([
		z.object({
			applicationOrder: z.number().optional(),
			content: z.union([
				z.string(),
				z
					.function(z.tuple([z.union([z.any(), z.undefined()]), z.union([z.any(), z.undefined()])]))
					.returns(z.union([z.promise(z.string()), z.string()])),
			]),
			order: z.number().optional(),
			required: z.boolean().optional(),
		}),
		z.string(),
	]),
)

// Turns a nested json object into a flat object with dot notation keys
function flattenJson(
	jsonObject: JsonObject,
	parentKey: keyof JsonObject = '',
	result: Record<string, string> = {},
): Record<string, string> {
	for (const [key, value] of Object.entries(jsonObject)) {
		const fullPath = parentKey ? `${parentKey}.${key}` : key

		if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
			flattenJson(value as JsonObject, fullPath, result)
		} else if (value === null) {
			result[fullPath] = 'null'
		} else {
			result[fullPath] = value.toString()
		}
	}

	return result
}

export function getSoleRule<T extends NormalizedRules | Rules>(rules: T): T[keyof T] {
	return getSoleRecord<T[keyof T]>(rules as Record<string, T[keyof T]>)
}
