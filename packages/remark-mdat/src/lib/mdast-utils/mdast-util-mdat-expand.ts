import { saveLog } from '../mdat/mdat-log'
import { type CommentMarkerNode, parseCommentNode } from '../mdat/parse'
import { type Rules, loadRules } from '../mdat/rules'
import type { Html, Root } from 'mdast'
import { remark } from 'remark'
import remarkGfm from 'remark-gfm'
import { CONTINUE, visit } from 'unist-util-visit'
import { type VFile } from 'vfile'

export type Options = {
	addMetaComment: boolean
	closingPrefix: string
	keywordPrefix: string
	metaCommentIdentifier: string
	rules: Array<Rules | string>
}

type ValidCommentMarker = CommentMarkerNode & {
	type: 'close' | 'open'
}

/*
 * Mdast utility plugin to collapse mdat comments and strip generated meta
 * comments, effectively resetting the document to its original state.
 */

export async function mdatExpand(tree: Root, file: VFile, options: Options) {
	const { addMetaComment, closingPrefix, keywordPrefix, metaCommentIdentifier, rules } = options

	const resolvedRules = await loadRules(rules)

	// Get all valid comment markers from the tree
	const commentMarkers: ValidCommentMarker[] = []
	visit(tree, 'html', (node, index, parent) => {
		if (parent === undefined || index === undefined) return CONTINUE

		// Find all <!-- mdat --> comments
		const commentMarker = parseCommentNode(node, parent, {
			closingPrefix,
			keywordPrefix,
			metaCommentIdentifier,
		})

		// Save the marker if it meets all criteria
		if (
			commentMarker !== undefined &&
			commentMarker.type === 'open' &&
			resolvedRules[commentMarker.keyword] !== undefined
		)
			commentMarkers.push(commentMarker)
	})

	// Sort by application order
	commentMarkers.sort(
		(a, b) => resolvedRules[a.keyword].applicationOrder - resolvedRules[b.keyword].applicationOrder,
	)

	// Expand the rules
	for (const comment of commentMarkers) {
		const { closingPrefix, html, keyword, keywordPrefix, node, parameters, parent } = comment
		const rule = resolvedRules[keyword]

		let newMarkdownString = ''
		try {
			newMarkdownString = await rule.content(parameters, tree)

			if (newMarkdownString === '') {
				saveLog(file, 'error', 'expand', `Got empty content when expanding ${html}`, node)
			}
		} catch (error) {
			if (error instanceof Error) {
				saveLog(file, 'error', 'expand', `Caught error expanding ${html} "${error.message}"`, node)
			}

			continue
		}

		// String to markdown Nodes
		const newNodes = remark().use(remarkGfm).parse(newMarkdownString).children

		// Add closing tag
		const closingNode: Html = {
			type: 'html',
			value: `<!-- ${closingPrefix}${keywordPrefix}${keyword} -->`,
		}

		const openingCommentIndex = parent.children.indexOf(node)
		parent.children.splice(openingCommentIndex + 1, 0, ...newNodes, closingNode)

		saveLog(file, 'info', 'expand', `Expanded: ${html}`, node)
	}

	// Add meta comment
	if (addMetaComment) {
		const message = 'Warning: Content in HTML comment blocks generated by mdat'
		const date = new Date().toISOString().slice(0, 10)
		const metaComment: Html = {
			type: 'html',
			value: `<!--${metaCommentIdentifier} ${message} on ${date} ${metaCommentIdentifier}-->`,
		}
		tree.children.unshift(metaComment)
	}
}
