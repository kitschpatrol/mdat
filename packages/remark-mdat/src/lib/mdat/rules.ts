import { type Root } from 'mdast'
import { type JsonValue } from 'type-fest'
import type { Merge, MergeDeep, SetOptional, Simplify } from 'type-fest'
import { z } from 'zod'

// Note that ore advanced rule loading is implemented in `/packages/mdat`

// Type-fest's internal SimplifyDeep implementation is not exported
// this isn't quite the same, but works for our purposes
type SimplifyDeep<T> = Simplify<MergeDeep<T, T>>

// Basic interface for comment expanders

/**
 * Strict normalized rules used internally.
 * Rules normalized to a form with async content functions and other default metadata
 * Simplifies processing elsewhere, while retaining flexibility for rule authors
 */
export type NormalizedRule = Simplify<
	NormalizedRuleCompoundComponent | NormalizedRuleObjectComponent
>

type NormalizedRuleObjectComponent = {
	/**
	 * The order in which the rule should be applied during processing
	 * Helpful if a rule depends on the presence of content generated by another rule
	 * Defaults to 0.
	 */
	applicationOrder: number
	/**
	 * The function that generates the expansion markdown string.
	 */
	content: (options: JsonValue, ast: Root) => Promise<string>
	/**
	 * The expected order of the keyword in the document relative to other expander comments.
	 * Used for validation purposes.
	 * Leave undefined to order skip validation.
	 * Defaults to undefined, which means order is not enforced.
	 */
	order: number | undefined
	/**
	 * Whether the presence of the keyword comment in the document is required.
	 * Used for validation purposes.
	 * Defaults to false.
	 */
	required: boolean
}

type NormalizedRuleCompoundComponent = NormalizedRuleObjectComponent[]

type Rule = RuleCompoundComponent | RuleObjectComponent

// More flexible rules used in the public interface
type RuleObjectComponent =
	/**
	 * Function that returns the markdown string to expand at the comment site.
	 */
	| ((options: JsonValue, ast: Root) => Promise<string> | string)
	| SetOptional<
			Merge<
				NormalizedRuleObjectComponent,
				{
					/**
					 * Gets content to expand into the comment.
					 * Can be a simple string for direct replacement, a function that returns a string, or an async function that returns a string.
					 *
					 * If a function is provided, it will be passed the following arguments:
					 *
					 * @param options
					 * JSON object of options parsed from the comment site, e.g.:
					 * `<!-- keyword({something: true}) -->` or
					 * `<!-- keyword {something: true}-->`
					 * Sets options to {something: true}
					 *
					 * @param ast
					 * Markdown abstract syntax tree containing the entire parsed document. Useful for expanders that need the entire document context, such as when generating a table of contents. Do not mutate the AST, instead return a new string.
					 *
					 * @returns A string with the generated content. The string will be parsed as markdown and inserted into the document at the comment's location.
					 */
					content: ((options: JsonValue, ast: Root) => Promise<string> | string) | string
				}
			>,
			'applicationOrder' | 'order' | 'required'
	  >
	/**
	 * The markdown string to expand at the comment site.
	 */
	| string

type RuleCompoundComponent = RuleObjectComponent[]

/**
 * Rules are record objects whose keys match strings inside a Markdown comment, and values explain what should be expanded at the comment site.
 *
 * The record value may be a string, or an object containing additional metadata, possibly with a function to invoke to generate content.
 *
 * @example Most basic rule:
 * { basic: 'content' }
 *
 * @example Rule with dynamic content:
 * { basic: () => `${new Date().toISOString()}` }
 *
 * @example Rule with metadata:
 * { basic-meta: { required: true, content: 'content'} }
 *
 * @example Rule with dynamic content and metadata:
 * { basic-date: { required: true, content: () => `${new Date().toISOString()}` } }
 */
export type Rules = SimplifyDeep<Record<string, Rule>>

export type NormalizedRules = SimplifyDeep<Record<string, NormalizedRule>>

// Helpers
export function normalizeRules(rules: Rules): NormalizedRules {
	const normalizedRules: NormalizedRules = {}

	for (const [keyword, rule] of Object.entries(rules)) {
		if (typeof rule === 'string') {
			// Rule is just a simple string replacement, no metadata provided
			normalizedRules[keyword] = {
				applicationOrder: 0,
				// eslint-disable-next-line @typescript-eslint/require-await
				content: async () => rule,
				order: undefined,
				required: false,
			}
		} else if (typeof rule === 'function') {
			// Rule is a function that returns a string
			// Wrapped so it can be sync or async
			normalizedRules[keyword] = {
				applicationOrder: 0,
				content: async (options: JsonValue, ast: Root) => rule(options, ast),
				order: undefined,
				required: false,
			}
		} else if (Array.isArray(rule)) {
			// Compound rules become an array of rules. No keywords.
			normalizedRules[keyword] = Object.values(
				normalizeRules(Object.fromEntries(rule.entries())),
			) as NormalizedRuleObjectComponent[] // TODO avoid the cast?
		} else if (typeof rule.content === 'string') {
			// Rule is a string replacement with metadata
			// Merge any existing metadata, but turn content into a function
			const ruleContent = rule.content // Needed for type narrowing
			normalizedRules[keyword] = {
				applicationOrder: rule.applicationOrder ?? 0,
				// eslint-disable-next-line @typescript-eslint/require-await
				content: async () => ruleContent,
				order: rule.order ?? undefined,
				required: rule.required ?? false,
			}
		} else {
			// Rule content returns a function, wrapped so it can be sync or async
			const ruleContent = rule.content // Needed for type narrowing
			normalizedRules[keyword] = {
				applicationOrder: rule.applicationOrder ?? 0,
				content: async (options: JsonValue, ast: Root) => ruleContent(options, ast),
				order: rule.order ?? undefined,
				required: rule.required ?? false,
			}
		}
	}

	validateNormalizedRules(normalizedRules)
	return normalizedRules
}

export function validateRules(rules: Rules) {
	// Check, throws on errors
	try {
		rulesSchema.parse(rules)
	} catch (error) {
		if (error instanceof Error) {
			throw new TypeError(`Error validating rules: ${error.message}`)
		}
	}
}

function validateNormalizedRules(rules: NormalizedRules) {
	// Check, throws on errors
	try {
		normalizedRulesSchema.parse(rules)
	} catch (error) {
		if (error instanceof Error) {
			throw new TypeError(`Error validating rules: ${error.message}`)
		}
	}
}

// Some duplication here, but less painful than inferring the TS types
// from more extensive Zod schemas that would require more extensive duplication
// of the JsonValue and Root types.

const ruleContentFunctionSchema = z
	.function(z.tuple([z.union([z.any(), z.undefined()]), z.union([z.any(), z.undefined()])]))
	.returns(z.union([z.promise(z.string()), z.string()]))

const normalizedRuleObjectComponentSchema = z.union([
	z.object({
		applicationOrder: z.number(),
		content: z.union([z.string(), ruleContentFunctionSchema]),
		order: z.number().optional(),
		required: z.boolean(),
	}),
	z.string(),
])

const normalizedRuleCompoundComponentSchema = z.array(normalizedRuleObjectComponentSchema)

const normalizedRulesSchema = z
	.record(z.union([normalizedRuleObjectComponentSchema, normalizedRuleCompoundComponentSchema]))
	.describe('Mdat Normalized Rules')

const ruleObjectComponentSchema = z.union([
	z.object({
		applicationOrder: z.number().optional(),
		content: z.union([z.string(), ruleContentFunctionSchema]),
		order: z.number().optional().optional(),
		required: z.boolean().optional(),
	}),
	z.string(),
	ruleContentFunctionSchema,
])

const ruleCompoundComponentSchema = z.array(ruleObjectComponentSchema)

export const rulesSchema = z
	.record(z.union([ruleObjectComponentSchema, ruleCompoundComponentSchema]))
	.describe('Mdat Rules')

// Compound rule helpers, used in both "expand" and "check" utilities
export async function getRuleContent(
	rule: NormalizedRule,
	parameters: JsonValue,
	ast: Root,
): Promise<string> {
	if (Array.isArray(rule)) {
		// TODO add check for array parameters?

		const subruleContent = await Promise.all(
			rule.map(async (singleRule, index) =>
				singleRule.content((Array.isArray(parameters) && parameters.at(index)) ?? {}, ast),
			),
		)
		return subruleContent.join('\n\n')
	}

	return rule.content(parameters, ast)
}

export function getApplicationOder(rule: NormalizedRule): number {
	if (Array.isArray(rule)) {
		// Highest order of any subrule
		return rule.reduce(
			(maxApplicationOrder, subrule) => Math.max(maxApplicationOrder, subrule.applicationOrder),
			0,
		)
	}

	return rule.applicationOrder
}

export function getOrder(rule?: NormalizedRule): number | undefined {
	if (rule === undefined) return undefined
	if (Array.isArray(rule)) {
		if (rule.every((subrule) => subrule.order === undefined)) return undefined
		// Highest order of any subrule
		return rule.reduce((order, subrule) => Math.max(order, subrule.order ?? 0), 0)
	}

	return rule.order
}

export function getRequired(rule: NormalizedRule): boolean {
	return Array.isArray(rule) ? rule.some((subrule) => subrule.required) : rule.required
}

export function getSoleRule<T extends NormalizedRules | Rules>(rules: T): T[keyof T] {
	return getSoleRecord<T[keyof T]>(rules as Record<string, T[keyof T]>)
}

export function getSoleRuleKey<T extends NormalizedRules | Rules>(rules: T): keyof T {
	const keys = Object.keys(rules)
	if (keys.length !== 1) {
		throw new Error(`Expected exactly one rule, found ${keys.length}`)
	}

	return keys[0]
}

/**
 * Get the sole entry in a record.
 *
 * Useful for working with Rules records
 * that are only supposed to contain a single rule.
 *
 * @param record The record to get the sole entry from
 * @returns The value of the sole entry in the record
 * @throws If there are no entries or more than one entry
 */
function getSoleRecord<V>(record: Record<string, V>): V {
	const recordValues = Object.values(record)
	if (recordValues.length === 0) {
		throw new Error('Found no entries in a "sole record" record. This should never happen')
	}

	if (recordValues.length > 1) {
		throw new Error('Found multiple entries in "sole record" record. This should never happen')
	}

	return recordValues[0]
}
